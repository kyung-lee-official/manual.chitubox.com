export function getDocContexts(
	docsContext: any,
	urlLocale: string,
	docInstance: string,
	versionCode: string,
	pathname: string
) {
	/* Get the localized context, which contains the context of all doc instances for the designated language. */
	const localizedContext = docsContext.find((locallizedSidebar: any) => {
		return locallizedSidebar.locale === urlLocale;
	});

	/* Get the doc instance context, which contains all version contexts of the designated doc instance. */
	const docInstanceContext = localizedContext!.localizedDocInstances.find(
		(localizedDocInstance: any) => {
			return localizedDocInstance.docInstance === docInstance;
		}
	);

	/* Get the versioned context, which contains all page contexts of the designated doc instance and version. */
	const versionedContext = docInstanceContext?.versionedContexts.find(
		(versionedContext: any) => {
			return versionedContext.versionCode === versionCode;
		}
	);
	const matchReg = /^v\d+\.\d+\.\d+$|latest/y;
	if (versionedContext?.versionCode.match(matchReg) === null) {
		/* No matched version */
	}

	/* Get the page context, which contains all TOC contexts of the designated page. */
	const flattenPagesContext = getFlattenPagesContext(
		versionedContext?.pagesContext
	);
	const pageContext = flattenPagesContext?.find((pageContext: any) => {
		return pageContext.path === pathname;
	});
	return {
		localizedContext,
		docInstanceContext,
		versionedContext,
		flattenPagesContext,
		pageContext,
	};
}

/**
 * Return a flatten pagesContext
 * @param pagesContext pagesContext of a specific version
 * @returns flatten pages Context
 */
export function getFlattenPagesContext(pagesContext: any) {
	const pageStack: any[] = [];
	function recursePagesContext(pagesContext: any) {
		for (const item of pagesContext) {
			if (item.subItems) {
				/* Has subitems */
				recursePagesContext(item.subItems);
			} else {
				/* Has no subitems */
				pageStack.push(item);
			}
		}
	}
	if (!pagesContext) {
		return null;
	}
	recursePagesContext(pagesContext);
	return pageStack;
}

/**
 * Return a flatten TOC
 * @param toc toc generated by rehype plugin @stefanprobst/rehype-extract-toc
 * @returns flatten TOC
 */
export function getFlattenToc(toc: any) {
	function recurseToc(toc: any) {
		for (const item of toc) {
			if (item.children) {
				/* Has subitems */
				tocStack.push({
					value: item.value,
					depth: item.depth,
					id: item.id,
				});
				recurseToc(item.children);
			} else {
				/* Has no subitems */
				tocStack.push({
					value: item.value,
					depth: item.depth,
					id: item.id,
				});
			}
		}
	}

	if (!toc) {
		return null;
	}
	const tocStack: any[] = [];
	recurseToc(toc);
	return tocStack;
}
