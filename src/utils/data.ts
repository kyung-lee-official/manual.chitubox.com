import GithubSlugger from "github-slugger";

export function getDocContexts(
	docsContext: any,
	urlLocale: string,
	docInstance: string,
	versionCode: string,
	pathname: string
) {
	/* Get the localized context, which contains the context of all doc instances for the designated language. */
	const localizedContext = docsContext.find((locallizedSidebar: any) => {
		return locallizedSidebar.locale === urlLocale;
	});

	/* Get the doc instance context, which contains all version contexts of the designated doc instance. */
	const docInstanceContext = localizedContext!.localizedDocInstances.find(
		(localizedDocInstance: any) => {
			return localizedDocInstance.docInstance === docInstance;
		}
	);

	/* Get the versioned context, which contains all page contexts of the designated doc instance and version. */
	const versionedContext = docInstanceContext?.versionedContexts.find(
		(versionedContext: any) => {
			return versionedContext.versionCode === versionCode;
		}
	);
	const matchReg = /^v\d+\.\d+\.\d+$|latest/y;
	if (versionedContext?.versionCode.match(matchReg) === null) {
		/* No matched version */
	}

	/* Get the page context, which contains all TOC contexts of the designated page. */
	const flattenPagesContext = getFlattenPagesContext(
		versionedContext?.pagesContext
	);
	const pageContext = flattenPagesContext?.find((pageContext: any) => {
		return pageContext.path === pathname;
	});
	return {
		localizedContext,
		docInstanceContext,
		versionedContext,
		flattenPagesContext,
		pageContext,
	};
}

/**
 * Return a flatten pagesContext
 * @param pagesContext pagesContext of a specific version
 * @returns flatten pages Context
 */
export function getFlattenPagesContext(pagesContext: any) {
	const pageStack: any[] = [];
	function recursePagesContext(pagesContext: any) {
		for (const item of pagesContext) {
			if (item.subItems) {
				/* Has subitems */
				recursePagesContext(item.subItems);
			} else {
				/* Has no subitems */
				pageStack.push(item);
			}
		}
	}
	if (!pagesContext) {
		return null;
	}
	recursePagesContext(pagesContext);
	return pageStack;
}

/**
 * Return a flatten TOC
 * @param toc toc generated by rehype plugin @stefanprobst/rehype-extract-toc
 * @returns flatten TOC
 */
export function getFlattenToc(toc: any) {
	function recurseToc(toc: any) {
		for (const item of toc) {
			if (item.children) {
				/* Has subitems */
				tocStack.push({
					value: item.value,
					depth: item.depth,
					id: item.id,
				});
				recurseToc(item.children);
			} else {
				/* Has no subitems */
				tocStack.push({
					value: item.value,
					depth: item.depth,
					id: item.id,
				});
			}
		}
	}

	if (!toc) {
		return null;
	}
	const tocStack: any[] = [];
	recurseToc(toc);
	return tocStack;
}

/**
 * Return a flatten TOC
 * @param toc toc generated by rehype plugin @stefanprobst/rehype-extract-toc
 * @deprecated old version of getFlattenToc
 * @returns flatten TOC
 */
export function getFlattenTocOld(toc: any) {
	const tocStack: any[] = [];
	function recurseToc(toc: any) {
		for (const item of toc) {
			if (item.children) {
				/* Has subitems */
				tocStack.push({
					value: item.value,
					depth: item.depth,
					id: item.id,
				});
				recurseToc(item.children);
			} else {
				/* Has no subitems */
				tocStack.push({
					value: item.value,
					depth: item.depth,
					id: item.id,
				});
			}
		}
	}
	recurseToc(toc);
	return tocStack;
}

/**
 * Return a flatten pagesContext
 * @param pagesContext pagesContext of a specific version
 * @deprecated old version of getFlattenPagesContext
 * @returns flatten pages Context
 */
export function getFlattenPagesContextOld(pagesContext: any) {
	const pageStack: any[] = [];
	function recursePagesContext(pagesContext: any) {
		for (const item of pagesContext) {
			if (item.subItems) {
				/* Has subitems */
				recursePagesContext(item.subItems);
			} else {
				/* Has no subitems */
				pageStack.push(item);
			}
		}
	}
	recursePagesContext(pagesContext);
	return pageStack;
}

/**
 * @deprecated Since rehype-slug uses github-slugger, this function is no longer used.
 * Return a URL-friendly slugified string, ex. convert "This is a string" to "this-is-a-string"
 * @param text string to slugify
 * @returns slugified string
 */
export function slugify(text: string) {
	return text
		.toLowerCase()
		.replace(/[~!@$^.'*()/ ]/g, "-")
		.replace(/-+/g, "-");
}

/**
 * @deprecated Since rehype-slug uses rehype-slug, which generates id
 * in the toc object, this function is no longer used.
 * Return a new flatten TOC with anchors, doesn't change the original flatten TOC
 * @param flattenToc flattenToc
 */
export function withAnchor(flattenToc: any) {
	const duplicateFlattenToc = JSON.parse(JSON.stringify(flattenToc));
	const slugger = new GithubSlugger();
	for (const item of duplicateFlattenToc) {
		const originalAnchor = "#" + slugger.slug(item.value);
		const duplicateAnchor = duplicateFlattenToc.find((item: any) => {
			return item.anchor === originalAnchor;
		});
		if (duplicateAnchor) {
			item.anchor = generateNewAnchor(
				originalAnchor,
				duplicateFlattenToc
			);
		} else {
			item.anchor = originalAnchor;
		}
	}

	/**
	 * Returns a unique anchor by given origianl anchor and flatten TOC
	 * @param originalAnchor the original anchor
	 * @param flattenToc the flatten TOC for comparison
	 * @param i optional, the index for resursion
	 * @returns unique anchor
	 */
	function generateNewAnchor(
		originalAnchor: string,
		flattenToc: any,
		i?: number
	): any {
		if (!i) {
			i = 1;
		}
		const duplicateAnchor = flattenToc.find((item: any) => {
			return item.anchor === `${originalAnchor}-${i}`;
		});
		if (duplicateAnchor) {
			return generateNewAnchor(originalAnchor, flattenToc, i + 1);
		} else {
			return `${originalAnchor}-${i}`;
		}
	}

	return duplicateFlattenToc;
}
